#!/usr/bin/env python3

"""
threefive command line SCTE35 decoder.

"""


import sys
from new_reader import reader
from threefive import Cue, Stream, print2, decode, version
from threefive.sixfix import sixfix
from threefive.superkabuki import SuperKabuki
from threefive.showcues import cli as hlscli
from sideways import cli as sidecli

REV = "\033[7;1m"
NORM = "\033[27m\033[0m"
NORM = "\033[0m"
BLUE = "\033[36;1;51m"

B = "\033[7;1m"
U = "\033[m"
mapped = {
    "base64": "encode",
    "bytes": "get_bytes",
    "hex": "encode2hex",
    "json": "get_json",
    "int": "encode2int",
    "xml": "xml",
}


def xml_out(cue):
    """
    xml_out prints cue as xml
    """
    print2(cue.xml())

def xml_out_binary(cue):
    """
    xml_out prints cue as xml
    """
    print2(cue.xml(binary=True))



class SupaStream(Stream):
    """
    SupaStream is subclass of Stream used
    to print raw SCTE-35 packets.
    """

    def _parse_scte35(self, pkt, pid):
        print2(pkt)
        super()._parse_scte35(pkt, pid)


def mk_sidecar(cue):
    """
    mk_sidecar generates a sidecar file with the SCTE-35 Cues
    """
    pts = 0.0
    with open("sidecar.txt", "a") as sidecar:
        cue.show()
        if cue.packet_data.pts:
            pts = cue.packet_data.pts
        data = f"{pts},{cue.encode()}\n"
        sidecar.write(data)


HELP = f"""
threefive                    {U}

{U}{B}    decode    {U} {BLUE}Decode SCTE-35 from Base64,Hex,MPEGTS, etc..{NORM}

{BLUE}base64:     {NORM}threefive '/DAWAAAAAAAAAP/wBQb+AKmKxwAACzuu2Q=='

{BLUE}Hex: {NORM}       threefive 0xfc301600000000000000fff00506fe00a98ac700000b3baed9

{BLUE}Files:     {NORM} threefive myvideo.ts

{BLUE}Stdin:     {NORM} cat myvideo.ts | threefive

{BLUE}Http(s):   {NORM} threefive https://futzu.com/xaa.ts

{BLUE}Multicast: {NORM} threefive udp://@235.35.3.5:3535

{U}{B}    encode   {U}{BLUE} Encode SCTE-35 to JSON, XML, Base64, Hex, Int etc.. {NORM}

{BLUE}Base64 to Hex:{NORM}\tthreefive  encode hex {U} '/DAlAAAAAAAAAP/wFAUAAAAOf+/+FOvVwP4ApMuAAA4AAAAAzBon0A=='

{BLUE}Hex to Xml:{NORM}\tthreefive  encode xml {U} '0xfc301600000000000000fff00506fe00a98ac700000b3baed9' 

{BLUE}JSON to Base64:{NORM} threefive  encode {U} < json.json

{BLUE}JSON to Xml:{NORM} threefive  encode  xml {U} < json.json

{BLUE}Xml to Hex:{NORM} cat xml.xml | threefive  encode hex {U}

{U}{B}    hls      {U}

{NORM}{BLUE}HLS decode SCTE-35:{NORM} threefive hls help

{BLUE}HLS encode SCTE-35:{U} threefive hls encode help{U}

{U}{B}    xml      {U}{NORM}{BLUE} Xml output:{NORM}

threefive xml '/DAsAAAAAAAAAP/wBQb+7YaD1QAWAhRDVUVJAADc8X+/DAVPVkxZSSIAAJ6Gk2Q='

threefive xml https://your-momma.com/video.ts

{U}{B}    inject   {U}{NORM}{BLUE} Inject an mpegts stream with a SCTE-35 sidecar file at pid:{NORM}

threefive inject video.ts with sidecar.txt at 333

{U}{B}    packets  {U}{NORM}{BLUE} Print raw SCTE-35 packets from multicast mpegts video:{NORM}

threefive packets udp://@235.35.3.5:3535

{U}{B}    proxy    {U}{NORM}{BLUE} Parse a https stream and write raw video to stdout:{NORM}

threefive proxy https://example.com/video.ts

{U}{B}    pts      {U}{NORM}{BLUE} Print PTS from mpegts video:{NORM} threefive pts video.ts

{U}{B}    sidecar  {U}{NORM}{BLUE} Parse a stream, write pts,write SCTE-35 Cues to sidecar.txt:{NORM}

threefive sidecar https://example.com/video.ts

{U}{B}    sixfix   {U}{NORM}{BLUE} Fix SCTE-35 data mangled by ffmpeg:{NORM} threefive sixfix video.ts

{U}{B}    show     {U}{NORM}{BLUE} Probe mpegts video:{NORM} threefive show video.ts

{U}{B}    version  {U}{NORM}{BLUE} Show version:{NORM} threefive version
                    
{U}{B}    help     {U}{NORM} {BLUE}Help:{NORM} threefive help
"""


def print_help():
    """
    print_help checks sys.argv for the word help
    and displays the help if found
    """
    print2(HELP)
    sys.exit()


def print_version():
    """
    version_chk checks for the version keyword.

    """
    print2(f"{version}")
    sys.exit()


def json_load():
    """
    json_load is used by encode
    """
    cmdlist = list(mapped.keys()) + ["encode","binary"]
    if "help" in sys.argv:
        encode_help()
        sys.exit()
    json = False
    arglist = [arg for arg in sys.argv[1:] if arg not in cmdlist]
    if not arglist:
        with reader(sys.stdin.buffer) as stuff:
            json = stuff.read().decode()
            arglist.append(json)
    for that in arglist:
        try:
            cue = Cue()
            cue.load(that)
        except:
            try:
                cue = Cue(that)
                cue.decode()
            except:
                print2("threefive accepts json, xml, base64, or hex as input")
                return False
        cue.encode()
        for k, v in mapped.items():
            if k in sys.argv:
                method = getattr(cue, v)
                if 'binary' in sys.argv and 'xml' in sys.argv:
                    print2(method(binary=True))
                else:
                    print2(method())
                sys.exit()

    print2(cue.encode())
    sys.exit()


def superkabuki():
    args = {}
    if "inject" in sys.argv:
        args["input"] = sys.argv[sys.argv.index("inject") + 1]
        if "with" in sys.argv:
            args["sidecar"] = sys.argv[sys.argv.index("with") + 1]
            if "at" in sys.argv:
                args["scte35_pid"] = sys.argv[sys.argv.index("at") + 1]
                supak = SuperKabuki()
                supak.apply_args(args)
                supak.encode()
                return True
    print2("threefive mpegts inject {infile} with {sidecar_file} at {pid}")
    return False


def hls():
    sys.argv.remove('hls')
    if "encode" in sys.argv:
        sidecli()
    else:
        hlscli()


def no_op(cue):
    """
    no_op is just a dummy func to pass to Stream.decode()
    to suppress output.
    """
    return cue


def packet_chk(this):
    """
    packet_chk checks for the packet keyword
    and displays SCTE-35 packets if present.
    """
    supa = SupaStream(this)
    supa.decode()


def proxy_chk(this):
    """
    proxy_chk checks for the proxy keyword
    and proxies the stream to stdout if present.
    proxy_chk also writes pts,cue pairs to sidecar.txt
    """
    strm = Stream(this)
    strm.proxy(func=mk_sidecar)


def pts_chk(this):
    """
    pts_chk is used to display PTS.
    """
    strm = Stream(this)
    strm.show_pts()


def show_chk(this):
    """
    show_chk checks for the show keyword
    and displays the streams if present.
    """
    strm = Stream(this)
    strm.show()


def sidecar_chk(this):
    """
    sidecar_chk checks for the sidecar keyword and
    generates a sidecar file if present.
    """
    strm = Stream(this)
    strm.decode(func=mk_sidecar)


def to_xml(this):
    """
    to_xml prints cues as xml instead of json.
    """
    try:
        # Mpegts Video
        strm = Stream(this)
        if 'binary' in  sys.argv:
            strm.decode(func=xml_out_binary)
        else:
            strm.decode(func=xml_out)
        return True

    except:
        binary=False
        try:
            cue = Cue(this)
            cue.decode()
            if 'binary' in sys.argv:
                binary=True
            print2(cue.xml(binary=binary))
            return True
        except:
            return False


func_map = {
    "xml": to_xml,
}


print_map = {
    "hls": hls,
    "encode": json_load,
   # "mpegts": mpegts,
    "help": print_help,
    "version": print_version,
    "inject": superkabuki,
}

mpegts_map = {
        "pts": pts_chk,
        "show": show_chk,
        "sixfix": sixfix,
        "packets": packet_chk,
        "proxy": proxy_chk,
        "sidecar": sidecar_chk,
       # "xml": to_xml,
}
    
def chk_print_map():
    """
    chk_print_map checks for print_map.keys() in sys.argv
    """
    for k, v in print_map.items():
        if k in sys.argv:
            v()
            sys.exit()


def chk_mpegts_map():
  #  sys.argv.remove("mpegts")
    for k, v in mpegts_map.items():
        if k in sys.argv:
            args = [arg for arg in sys.argv[1:] if arg not in mpegts_map]
            for mo in args:
                v(mo)
            sys.exit()


def chk_func_map():
    """
    chk_func_map checks for func_map.keys() in sys.argv
    """
    for k, v in func_map.items():
        if k in sys.argv:
            args = [arg for arg in sys.argv[1:] if arg not in func_map]
            for mo in args:
                v(mo)
            sys.exit()


if __name__ == "__main__":
    if len(sys.argv) > 1:
        chk_print_map()
        chk_mpegts_map()
        chk_func_map()
        for arg in sys.argv[1:]:
            decode(arg)
    else:
        decode(sys.stdin.buffer)
